import { HttpClient } from '@angular/common/http';
import { Directive, EventEmitter, Input, Output } from '@angular/core';
import { ShowdownComponent } from './showdown.component';
/**
 * A angular directive to `ShowdownComponent` for make http request of markdown content.
 *
 * ### Example
 *
 * Setup as standalone
 * ```typescript
 * import { NgModule } from '@angular/core';
 * import { HttpClientModule } from '@angular/common/http';
 * import { ShowdownComponent, SourceDirective } from 'ngx-showdown';
 *
 * @NgModule({
 *    declarations: [ ShowdownComponent, SourceDirective ],
 *    imports: [ HttpClientModule ]
 * })
 * export class AppModule {}
 * ```
 *
 * Bind url `src` directive
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *     selector: 'some',
 *     template: '<showdown [src]="url" smartIndentationFix>**Loading...**</showdown>
 * })
 * class SomeComponent {
 *     url: string = 'https://unpkg.com/ngx-showdown/README.md';
 *     // ...
 * }
 * ```
 *
 * Set static url
 * ```html
 * <showdown src="README.md" [options]="{noHeaderId: true}"></showdown>
 * ```
 *
 * Set template reference variable
 * ```html
 * <showdown #source="source" src="README.md"></showdown>
 * ```
 *
 * Listening to `error` events.
 * ```html
 * <showdown #sd src="http://url.error" (error)="sd.render('# '+$event.message)"></showdown>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './showdown.component';
import * as ɵngcc2 from '@angular/common/http';
export class SourceDirective {
    constructor(_showdownComponent, _http) {
        this._showdownComponent = _showdownComponent;
        this._http = _http;
        /**
         * On error occur.
         *
         * __Example :__
         *
         * ```html
         * <input type="text" placeholder="url" [(ngModel)]="url"/>
         * <showdown [src]="url" (error)="sd.render('# Error\n> '+$event.message)">**Loading...**</showdown>
         * ```
         */
        this.error = new EventEmitter();
    }
    /**
     * A angular lifecycle method, Use to call to `load` method on src init/changes
     * @internal
     */
    ngOnChanges() {
        this.load();
    }
    /**
     * Load the markdown content of {@link SourceDirective#src} url to {@link ShowdownComponent#value}.
     *
     * __Example :__
     *
     * ```html
     * <input type="text" #url value="source.src" placeholder="Url" />
     * <button (click)="source.load(url.value)">Load</button>
     * <showdown #source="source" src="https://unpkg.com/ngx-showdown/README.md"></showdown>
     * ```
     * @param url - A url of markdown content to load (it will override the current url of `SourceDirective#src`)
     */
    load(url) {
        if (url) {
            this.src = url;
        }
        if (this.src) {
            this
                ._http
                .get(this.src, { responseType: 'text' })
                .subscribe((response) => {
                this._showdownComponent.render(response);
            }, (error) => {
                this.error.emit(error);
            });
        }
    }
}
SourceDirective.ɵfac = function SourceDirective_Factory(t) { return new (t || SourceDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ShowdownComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.HttpClient)); };
SourceDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SourceDirective, selectors: [["showdown", "src", ""], ["", "showdown", "", "src", ""]], inputs: { src: "src" }, outputs: { error: "error" }, exportAs: ["source"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
SourceDirective.ctorParameters = () => [
    { type: ShowdownComponent },
    { type: HttpClient }
];
SourceDirective.propDecorators = {
    src: [{ type: Input }],
    error: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SourceDirective, [{
        type: Directive,
        args: [{
                selector: 'showdown[src],[showdown][src]',
                exportAs: 'source'
            }]
    }], function () { return [{ type: ɵngcc1.ShowdownComponent }, { type: ɵngcc2.HttpClient }]; }, { error: [{
            type: Output
        }], src: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3NvdXJjZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBcUIsTUFBTSxzQkFBc0IsQ0FBQztBQUNyRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWEsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7OztBQUtILE1BQU0sT0FBTyxlQUFlO0FBQUcsSUFpQzdCLFlBQW9CLGtCQUFxQyxFQUFVLEtBQWlCO0FBQ3RGLFFBRHNCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7QUFBQyxRQUFTLFVBQUssR0FBTCxLQUFLLENBQVk7QUFBQyxRQVpyRjtBQUNGO0FBRUM7QUFBVztBQUdaO0FBQVc7QUFBbUI7QUFDTTtBQUdUO0FBQWUsV0FEckM7QUFDTCxRQUFZLFVBQUssR0FBb0MsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUN4RSxJQUVFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRTtBQUNFLE9BQUM7QUFDTCxJQUFFLFdBQVc7QUFBSyxRQUNkLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNoQixJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBRUg7QUFBTztBQUNFO0FBQ0U7QUFDRTtBQUVQO0FBQVc7QUFFSixPQURUO0FBQ0wsSUFBUyxJQUFJLENBQUMsR0FBWTtBQUFJLFFBQzFCLElBQUksR0FBRyxFQUFFO0FBQ2IsWUFBTSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNyQixTQUFLO0FBQ0wsUUFDSSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDbEIsWUFBTSxJQUFJO0FBQ1YsaUJBQVMsS0FBSztBQUNkLGlCQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUMsWUFBWSxFQUFFLE1BQU0sRUFBQyxDQUFDO0FBQzlDLGlCQUFTLFNBQVMsQ0FBQyxDQUFDLFFBQWdCLEVBQUUsRUFBRTtBQUN4QyxnQkFBVSxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ25ELFlBQVEsQ0FBQyxFQUFFLENBQUMsS0FBd0IsRUFBRSxFQUFFO0FBQ3hDLGdCQUFVLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2pDLFlBQVEsQ0FBQyxDQUFDLENBQUM7QUFDWCxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0g7MkNBNUVDLFNBQVMsU0FBQyxrQkFDVCxRQUFRLEVBQUUsK0JBQStCLGtCQUN6QyxRQUFRLEVBQUUsUUFBUSxjQUNuQjtzUUFDSTtBQUFDO0FBQXlDLFlBckR0QyxpQkFBaUI7QUFBSSxZQUZyQixVQUFVO0FBQUc7QUFBRztBQUFtQyxrQkEwRXpELEtBQUs7QUFBSyxvQkFZVixNQUFNO0FBQUk7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwQ2xpZW50LCBIdHRwRXJyb3JSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNob3dkb3duQ29tcG9uZW50IH0gZnJvbSAnLi9zaG93ZG93bi5jb21wb25lbnQnO1xuXG4vKipcbiAqIEEgYW5ndWxhciBkaXJlY3RpdmUgdG8gYFNob3dkb3duQ29tcG9uZW50YCBmb3IgbWFrZSBodHRwIHJlcXVlc3Qgb2YgbWFya2Rvd24gY29udGVudC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFNldHVwIGFzIHN0YW5kYWxvbmVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBIdHRwQ2xpZW50TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuICogaW1wb3J0IHsgU2hvd2Rvd25Db21wb25lbnQsIFNvdXJjZURpcmVjdGl2ZSB9IGZyb20gJ25neC1zaG93ZG93bic7XG4gKlxuICogQE5nTW9kdWxlKHtcbiAqICAgIGRlY2xhcmF0aW9uczogWyBTaG93ZG93bkNvbXBvbmVudCwgU291cmNlRGlyZWN0aXZlIF0sXG4gKiAgICBpbXBvcnRzOiBbIEh0dHBDbGllbnRNb2R1bGUgXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqIGBgYFxuICpcbiAqIEJpbmQgdXJsIGBzcmNgIGRpcmVjdGl2ZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdzb21lJyxcbiAqICAgICB0ZW1wbGF0ZTogJzxzaG93ZG93biBbc3JjXT1cInVybFwiIHNtYXJ0SW5kZW50YXRpb25GaXg+KipMb2FkaW5nLi4uKio8L3Nob3dkb3duPlxuICogfSlcbiAqIGNsYXNzIFNvbWVDb21wb25lbnQge1xuICogICAgIHVybDogc3RyaW5nID0gJ2h0dHBzOi8vdW5wa2cuY29tL25neC1zaG93ZG93bi9SRUFETUUubWQnO1xuICogICAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogU2V0IHN0YXRpYyB1cmxcbiAqIGBgYGh0bWxcbiAqIDxzaG93ZG93biBzcmM9XCJSRUFETUUubWRcIiBbb3B0aW9uc109XCJ7bm9IZWFkZXJJZDogdHJ1ZX1cIj48L3Nob3dkb3duPlxuICogYGBgXG4gKlxuICogU2V0IHRlbXBsYXRlIHJlZmVyZW5jZSB2YXJpYWJsZVxuICogYGBgaHRtbFxuICogPHNob3dkb3duICNzb3VyY2U9XCJzb3VyY2VcIiBzcmM9XCJSRUFETUUubWRcIj48L3Nob3dkb3duPlxuICogYGBgXG4gKlxuICogTGlzdGVuaW5nIHRvIGBlcnJvcmAgZXZlbnRzLlxuICogYGBgaHRtbFxuICogPHNob3dkb3duICNzZCBzcmM9XCJodHRwOi8vdXJsLmVycm9yXCIgKGVycm9yKT1cInNkLnJlbmRlcignIyAnKyRldmVudC5tZXNzYWdlKVwiPjwvc2hvd2Rvd24+XG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnc2hvd2Rvd25bc3JjXSxbc2hvd2Rvd25dW3NyY10nLFxuICBleHBvcnRBczogJ3NvdXJjZSdcbn0pXG5leHBvcnQgY2xhc3MgU291cmNlRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICAvKipcbiAgICogVGhlIHNvdXJjZSB1cmwgb2YgdGhlIG1hcmtkb3duIGNvbnRlbnQuXG4gICAqXG4gICAqIF9fRXhhbXBsZSA6X19cbiAgICpcbiAgICogU2V0IHN0YXRpYyB1cmwgdG8gYHNyY2AgZGlyZWN0aXZlLlxuICAgKiBgYGBodG1sXG4gICAqIDxzaG93ZG93biBzcmM9XCJodHRwczovL3VucGtnLmNvbS9uZ3gtc2hvd2Rvd24vUkVBRE1FLm1kXCI+PC9zaG93ZG93bj5cbiAgICogYGBgXG4gICAqXG4gICAqIEJpbmQgdXJsIHRvIGBzcmNgIGRpcmVjdGl2ZS5cbiAgICogYGBgaHRtbFxuICAgKiA8aW5wdXQgdHlwZT1cInRleHRcIiAjdXJsIHBsYWNlaG9sZGVyPVwidXJsXCIgLz5cbiAgICogPGJ1dHRvbiAoY2xpY2spPVwic3JjID0gdXJsLnZhbHVlXCI+TG9hZDwvYnV0dG9uPlxuICAgKiA8c2hvd2Rvd24gW3NyY109XCJzcmNcIj4qKkxvYWRpbmcuLi4qKjwvc2hvd2Rvd24+XG4gICAqIGBgYFxuICAgKi9cbiAgQElucHV0KCkgc3JjOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9uIGVycm9yIG9jY3VyLlxuICAgKlxuICAgKiBfX0V4YW1wbGUgOl9fXG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJ1cmxcIiBbKG5nTW9kZWwpXT1cInVybFwiLz5cbiAgICogPHNob3dkb3duIFtzcmNdPVwidXJsXCIgKGVycm9yKT1cInNkLnJlbmRlcignIyBFcnJvclxcbj4gJyskZXZlbnQubWVzc2FnZSlcIj4qKkxvYWRpbmcuLi4qKjwvc2hvd2Rvd24+XG4gICAqIGBgYFxuICAgKi9cbiAgQE91dHB1dCgpIGVycm9yOiBFdmVudEVtaXR0ZXI8SHR0cEVycm9yUmVzcG9uc2U+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3Nob3dkb3duQ29tcG9uZW50OiBTaG93ZG93bkNvbXBvbmVudCwgcHJpdmF0ZSBfaHR0cDogSHR0cENsaWVudCkge1xuICB9XG5cbiAgLyoqXG4gICAqIEEgYW5ndWxhciBsaWZlY3ljbGUgbWV0aG9kLCBVc2UgdG8gY2FsbCB0byBgbG9hZGAgbWV0aG9kIG9uIHNyYyBpbml0L2NoYW5nZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBuZ09uQ2hhbmdlcygpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBtYXJrZG93biBjb250ZW50IG9mIHtAbGluayBTb3VyY2VEaXJlY3RpdmUjc3JjfSB1cmwgdG8ge0BsaW5rIFNob3dkb3duQ29tcG9uZW50I3ZhbHVlfS5cbiAgICpcbiAgICogX19FeGFtcGxlIDpfX1xuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxpbnB1dCB0eXBlPVwidGV4dFwiICN1cmwgdmFsdWU9XCJzb3VyY2Uuc3JjXCIgcGxhY2Vob2xkZXI9XCJVcmxcIiAvPlxuICAgKiA8YnV0dG9uIChjbGljayk9XCJzb3VyY2UubG9hZCh1cmwudmFsdWUpXCI+TG9hZDwvYnV0dG9uPlxuICAgKiA8c2hvd2Rvd24gI3NvdXJjZT1cInNvdXJjZVwiIHNyYz1cImh0dHBzOi8vdW5wa2cuY29tL25neC1zaG93ZG93bi9SRUFETUUubWRcIj48L3Nob3dkb3duPlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHVybCAtIEEgdXJsIG9mIG1hcmtkb3duIGNvbnRlbnQgdG8gbG9hZCAoaXQgd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCB1cmwgb2YgYFNvdXJjZURpcmVjdGl2ZSNzcmNgKVxuICAgKi9cbiAgcHVibGljIGxvYWQodXJsPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zcmMgPSB1cmw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3JjKSB7XG4gICAgICB0aGlzXG4gICAgICAgIC5faHR0cFxuICAgICAgICAuZ2V0KHRoaXMuc3JjLCB7cmVzcG9uc2VUeXBlOiAndGV4dCd9KVxuICAgICAgICAuc3Vic2NyaWJlKChyZXNwb25zZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2hvd2Rvd25Db21wb25lbnQucmVuZGVyKHJlc3BvbnNlKTtcbiAgICAgICAgfSwgKGVycm9yOiBIdHRwRXJyb3JSZXNwb25zZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZXJyb3IuZW1pdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG59XG4iXX0=