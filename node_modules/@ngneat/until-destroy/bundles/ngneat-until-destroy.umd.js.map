{"version":3,"file":"ngneat-until-destroy.umd.js","sources":["../../src/lib/ivy.ts","../../src/lib/internals.ts","../../src/lib/until-destroy.ts","../../src/lib/until-destroyed.ts","../../src/ngneat-until-destroy.ts"],"names":["ɵNG_PIPE_DEF","Subject","takeUntil"],"mappings":"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","sourcesContent":["import { Type, ÉµNG_PIPE_DEF, ÉµPipeDef } from '@angular/core';\n\nconst NG_PIPE_DEF = ÉµNG_PIPE_DEF as 'Éµpipe';\n\n// Angular doesn't expose publicly `PipeType` but it actually has it.\nexport interface PipeType<T> extends Type<T> {\n  Éµpipe: ÉµPipeDef<T>;\n}\n\nexport function isPipe<T>(target: any): target is PipeType<T> {\n  return !!target[NG_PIPE_DEF];\n}\n","import { InjectableType, ÉµDirectiveType, ÉµComponentType } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { PipeType } from './ivy';\n\nexport function isFunction(target: unknown) {\n  return typeof target === 'function';\n}\n\n/**\n * Applied to instances and stores `Subject` instance when\n * no custom destroy method is provided.\n */\nconst DESTROY: unique symbol = Symbol('__destroy');\n\n/**\n * Applied to definitions and informs that class is decorated\n */\nconst DECORATOR_APPLIED: unique symbol = Symbol('__decoratorApplied');\n\n/**\n * If we use the `untilDestroyed` operator multiple times inside the single\n * instance providing different `destroyMethodName`, then all streams will\n * subscribe to the single subject. If any method is invoked, the subject will\n * emit and all streams will be unsubscribed. We wan't to prevent this behavior,\n * thus we store subjects under different symbols.\n */\nexport function getSymbol<T>(destroyMethodName?: keyof T): symbol {\n  if (typeof destroyMethodName === 'string') {\n    return Symbol(`__destroy__${destroyMethodName}`);\n  } else {\n    return DESTROY;\n  }\n}\n\nexport function markAsDecorated<T>(\n  type: InjectableType<T> | PipeType<T> | ÉµDirectiveType<T> | ÉµComponentType<T>\n): void {\n  // Store this property on the prototype if it's an injectable class, component or directive.\n  // We will be able to handle class extension this way.\n  type.prototype[DECORATOR_APPLIED] = true;\n}\n\nexport interface UntilDestroyOptions {\n  blackList?: string[];\n  arrayName?: string;\n  checkProperties?: boolean;\n}\n\nexport function ensureClassIsDecorated(instance: any): never | void {\n  if (missingDecorator(instance.constructor)) {\n    throw new Error(\n      'untilDestroyed operator cannot be used inside directives or ' +\n        'components or providers that are not decorated with UntilDestroy decorator'\n    );\n  }\n}\n\nexport function createSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (!instance[symbol]) {\n    instance[symbol] = new Subject<void>();\n  }\n}\n\nexport function completeSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (instance[symbol]) {\n    instance[symbol].next();\n    instance[symbol].complete();\n    // We also have to re-assign this property thus in the future\n    // we will be able to create new subject on the same instance.\n    instance[symbol] = null;\n  }\n}\n\nfunction missingDecorator<T>(\n  type: InjectableType<T> | PipeType<T> | ÉµDirectiveType<T> | ÉµComponentType<T>\n): boolean {\n  return !(DECORATOR_APPLIED in type.prototype);\n}\n","import {\n  InjectableType,\n  ÉµComponentType as ComponentType,\n  ÉµDirectiveType as DirectiveType\n} from '@angular/core';\nimport { SubscriptionLike } from 'rxjs';\n\nimport { PipeType, isPipe } from './ivy';\nimport {\n  getSymbol,\n  isFunction,\n  UntilDestroyOptions,\n  completeSubjectOnTheInstance,\n  markAsDecorated\n} from './internals';\n\nfunction unsubscribe(property: SubscriptionLike | undefined): void {\n  property && isFunction(property.unsubscribe) && property.unsubscribe();\n}\n\nfunction unsubscribeIfPropertyIsArrayLike(property: any[]): void {\n  Array.isArray(property) && property.forEach(unsubscribe);\n}\n\nfunction decorateNgOnDestroy(\n  ngOnDestroy: (() => void) | null | undefined,\n  options: UntilDestroyOptions\n) {\n  return function(this: any) {\n    // Invoke the original `ngOnDestroy` if it exists\n    ngOnDestroy && ngOnDestroy.call(this);\n\n    // It's important to use `this` instead of caching instance\n    // that may lead to memory leaks\n    completeSubjectOnTheInstance(this, getSymbol());\n\n    // Check if subscriptions are pushed to some array\n    if (options.arrayName) {\n      return unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);\n    }\n\n    // Loop through the properties and find subscriptions\n    if (options.checkProperties) {\n      for (const property in this) {\n        if (options.blackList?.includes(property)) {\n          continue;\n        }\n\n        unsubscribe(this[property]);\n      }\n    }\n  };\n}\n\nfunction decorateProviderDirectiveOrComponent<T>(\n  type: InjectableType<T> | DirectiveType<T> | ComponentType<T>,\n  options: UntilDestroyOptions\n): void {\n  type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);\n}\n\nfunction decoratePipe<T>(type: PipeType<T>, options: UntilDestroyOptions): void {\n  const def = type.Éµpipe;\n  def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);\n}\n\nexport function UntilDestroy(options: UntilDestroyOptions = {}): ClassDecorator {\n  return (type: any) => {\n    if (isPipe(type)) {\n      decoratePipe(type, options);\n    } else {\n      decorateProviderDirectiveOrComponent(type, options);\n    }\n\n    markAsDecorated(type);\n  };\n}\n","import { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport {\n  getSymbol,\n  isFunction,\n  createSubjectOnTheInstance,\n  completeSubjectOnTheInstance,\n  ensureClassIsDecorated\n} from './internals';\n\nfunction overrideNonDirectiveInstanceMethod(\n  instance: any,\n  destroyMethodName: string,\n  symbol: symbol\n): void {\n  const originalDestroy = instance[destroyMethodName];\n\n  if (isFunction(originalDestroy) === false) {\n    throw new Error(\n      `${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`\n    );\n  }\n\n  createSubjectOnTheInstance(instance, symbol);\n\n  instance[destroyMethodName] = function() {\n    isFunction(originalDestroy) && originalDestroy.apply(this, arguments);\n    completeSubjectOnTheInstance(this, symbol);\n    // We have to re-assign this property back to the original value.\n    // If the `untilDestroyed` operator is called for the same instance\n    // multiple times, then we will be able to get the original\n    // method again and not the patched one.\n    instance[destroyMethodName] = originalDestroy;\n  };\n}\n\nexport function untilDestroyed<T>(instance: T, destroyMethodName?: keyof T) {\n  return <U>(source: Observable<U>) => {\n    const symbol = getSymbol<T>(destroyMethodName);\n\n    // If `destroyMethodName` is passed then the developer applies\n    // this operator to something non-related to Angular DI system\n    if (typeof destroyMethodName === 'string') {\n      overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);\n    } else {\n      ensureClassIsDecorated(instance);\n      createSubjectOnTheInstance(instance, symbol);\n    }\n\n    return source.pipe(takeUntil<U>((instance as any)[symbol]));\n  };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"]}